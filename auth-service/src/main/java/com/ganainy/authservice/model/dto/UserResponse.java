package com.ganainy.authservice.model.dto;

<<<<<<< HEAD
import com.ganainy.authservice.model.entity.User;
=======
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;
>>>>>>> c91ebb48e3e199215cab9f2b70c7fb1847f4e963

import java.time.LocalDateTime;

/**
<<<<<<< HEAD
 * UserResponse - DTO for returning user data to clients.
 * 
 * =====================================================
 * WHY A SEPARATE RESPONSE DTO?
 * =====================================================
 * 
 * We NEVER want to send the password hash to clients!
 * Even though it's hashed, exposing it is a security risk.
 * 
 * The response DTO:
 * - Excludes sensitive fields (password)
 * - Can include computed fields
 * - Decouples API response from database schema
 */
public record UserResponse(
        Long id,
        String email,
        String firstName,
        String lastName,
        User.Role role,
        boolean enabled,
        LocalDateTime createdAt,
        LocalDateTime updatedAt) {
    /**
     * Factory method to convert a User entity to a UserResponse DTO.
     * 
     * This is a simple mapping approach. For complex mappings,
     * you'd use a library like MapStruct.
     */
    public static UserResponse fromEntity(User user) {
        return new UserResponse(
                user.getId(),
                user.getEmail(),
                user.getFirstName(),
                user.getLastName(),
                user.getRole(),
                user.isEnabled(),
                user.getCreatedAt(),
                user.getUpdatedAt());
    }
=======
 * UserResponse - DTO for returning user data in API responses.
 * 
 * =====================================================
 * KEY DIFFERENCE FROM ENTITY
 * =====================================================
 * 
 * Notice what's MISSING compared to the User entity:
 * ❌ password - NEVER expose passwords!
 * ❌ accountNonExpired - Internal status, not relevant to API consumers
 * ❌ credentialsNonExpired - Internal status
 * ❌ accountNonLocked - Internal status (though admin APIs might need this)
 * 
 * Only expose what the API consumer NEEDS to see.
 * 
 * =====================================================
 * WHEN TO USE THIS DTO
 * =====================================================
 * 
 * Use UserResponse when returning user data:
 * - GET /api/users/{id} → single UserResponse
 * - GET /api/users → List<UserResponse>
 * - POST /api/users → return created UserResponse
 * - PUT /api/users/{id} → return updated UserResponse
 * 
 * For login responses, you'd create a different DTO that includes the JWT
 * token.
 */
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class UserResponse {

    /**
     * Unique identifier (generated by database).
     */
    private Long id;

    /**
     * User's email address.
     */
    private String email;

    /**
     * User's first name.
     */
    private String firstName;

    /**
     * User's last name.
     */
    private String lastName;

    /**
     * Computed full name for convenience.
     * 
     * This shows how DTOs can add derived/computed fields
     * that don't exist in the entity!
     */
    private String fullName;

    /**
     * User's role (ADMIN, DOCTOR, NURSE, PATIENT, RECEPTIONIST).
     */
    private String role;

    /**
     * Whether the account is enabled (active).
     * 
     * This IS exposed because:
     * - Users need to know if their account is active
     * - Admins need to see account status
     */
    private boolean enabled;

    /**
     * When the account was created.
     * 
     * Useful for admins and audit purposes.
     */
    private LocalDateTime createdAt;

    /**
     * When the account was last updated.
     */
    private LocalDateTime updatedAt;
>>>>>>> c91ebb48e3e199215cab9f2b70c7fb1847f4e963
}
